"use strict";
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var __param = (this && this.__param) || function (paramIndex, decorator) {
    return function (target, key) { decorator(target, key, paramIndex); }
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const net_1 = __importDefault(require("net"));
const url_converter_1 = require("../util/url.converter");
const inversify_1 = require("inversify");
const dependency_injection_types_1 = require("./dependency.injection.types");
const auth_mode_enum_1 = require("../models/auth.mode.enum");
const nodeCommon = require("_http_common");
let self;
let NtlmProxyMitm = class NtlmProxyMitm {
    constructor(configStore, configServer, connectionContextManager, winSsoFacade, negotiateManager, ntlmManager, upstreamProxyManager, debug) {
        this._configStore = configStore;
        this._configServer = configServer;
        this._connectionContextManager = connectionContextManager;
        this.WinSsoFacade = winSsoFacade;
        this._negotiateManager = negotiateManager;
        this._ntlmManager = ntlmManager;
        this._upstreamProxyManager = upstreamProxyManager;
        this._debug = debug;
        // Keep track of instance since methods will be triggered from HttpMitmProxy
        // events which means that 'this' is no longer the class instance
        self = this;
    }
    get NtlmProxyPort() {
        if (this._ntlmProxyPort !== undefined) {
            return this._ntlmProxyPort;
        }
        throw new Error("Cannot get ntlmProxyPort, port has not been set!");
    }
    set NtlmProxyPort(port) {
        if (port === "") {
            this._ntlmProxyPort = undefined;
        }
        this._ntlmProxyPort = port;
    }
    filterChromeStartup(ctx, errno, errorKind) {
        if (!ctx || !ctx.clientToProxyRequest || !errno) {
            return false;
        }
        let req = ctx.clientToProxyRequest;
        if (req.method === "HEAD" &&
            req.url === "/" &&
            req.headers.host &&
            req.headers.host.indexOf(".") === -1 &&
            (req.headers.host.indexOf(":") === -1 ||
                req.headers.host.indexOf(":80") !== -1) &&
            req.headers.host.indexOf("/") === -1 &&
            errorKind === "PROXY_TO_SERVER_REQUEST_ERROR" &&
            errno === "ENOTFOUND") {
            self._debug.log("Chrome startup HEAD request detected (host: " +
                req.headers.host +
                "). Ignoring connection error.");
            return true;
        }
    }
    onError(ctx, error, errorKind) {
        if (self.filterChromeStartup(ctx, error.code, errorKind)) {
            return;
        }
        let url = ctx && ctx.clientToProxyRequest ? ctx.clientToProxyRequest.url : "";
        self._debug.log(errorKind + " on " + url + ":", error);
    }
    isConfigApiRequest(targetHost) {
        return targetHost.href.startsWith(self._configServer.configApiUrl);
    }
    onRequest(ctx, callback) {
        let targetHost = self.getTargetHost(ctx);
        if (targetHost) {
            let context = self._connectionContextManager.getConnectionContextFromClientSocket(ctx.clientToProxyRequest.socket);
            let useSso = self._configStore.useSso(targetHost);
            let useNtlm = useSso || self._configStore.exists(targetHost);
            if (context) {
                if (context.matchHostOrNew(targetHost) === false) {
                    self._debug.log("Existing client socket " +
                        context.clientAddress +
                        " received request to a different target, remove existing context");
                    self._connectionContextManager.removeAgent("reuse", context.clientAddress);
                    context = undefined;
                }
            }
            if (!context) {
                context = self._connectionContextManager.createConnectionContext(ctx.clientToProxyRequest.socket, ctx.isSSL, targetHost);
            }
            if (useNtlm) {
                self._debug.log("Request to " +
                    targetHost.href +
                    " in registered NTLM Hosts" +
                    (useSso ? " (using SSO)" : ""));
                ctx.proxyToServerRequestOptions.agent = context.agent;
                context.clearRequestBody();
                ctx.onRequestData(function (ctx, chunk, callback) {
                    context.addToRequestBody(chunk);
                    return callback(undefined, chunk);
                });
            }
            else {
                if (self.isConfigApiRequest(targetHost)) {
                    self._debug.log("Request to config API");
                    ctx.proxyToServerRequestOptions.agent = self._connectionContextManager.getUntrackedAgent(targetHost);
                }
                else {
                    self._debug.log("Request to " + targetHost.href + " - pass on");
                    ctx.proxyToServerRequestOptions.agent = context.agent;
                }
            }
            return callback();
        }
        else {
            // The http-mitm-proxy cannot handle this scenario, if no target host header
            // is set it will get stuck in an infinite loop
            return callback(new Error('Invalid request - Could not read "host" header or "host" header refers to this proxy'));
        }
    }
    isNtlmProxyAddress(hostUrl) {
        return hostUrl.isLocalhost && hostUrl.port === self.NtlmProxyPort;
    }
    getTargetHost(ctx) {
        if (!ctx.clientToProxyRequest.headers.host) {
            self._debug.log('Invalid request - Could not read "host" header from incoming request to proxy');
            return null;
        }
        let host = ctx.clientToProxyRequest.headers.host;
        let hostUrl = url_converter_1.toCompleteUrl(host, ctx.isSSL, true);
        if (self.isNtlmProxyAddress(hostUrl)) {
            self._debug.log("Invalid request - host header refers to this proxy");
            return null;
        }
        return hostUrl;
    }
    getAuthMode(serverToProxyResponse, useSso) {
        if (serverToProxyResponse.statusCode !== 401 ||
            !serverToProxyResponse.headers["www-authenticate"]) {
            return auth_mode_enum_1.AuthModeEnum.NotApplicable;
        }
        if (useSso &&
            self._negotiateManager.acceptsNegotiateAuthentication(serverToProxyResponse)) {
            return auth_mode_enum_1.AuthModeEnum.Negotiate;
        }
        if (self._ntlmManager.acceptsNtlmAuthentication(serverToProxyResponse)) {
            return auth_mode_enum_1.AuthModeEnum.NTLM;
        }
        // TODO Basic auth
        return auth_mode_enum_1.AuthModeEnum.NotSupported;
    }
    onResponse(ctx, callback) {
        let targetHost = self.getTargetHost(ctx);
        if (!targetHost) {
            return callback();
        }
        let useSso = self._configStore.useSso(targetHost);
        let useNtlm = useSso || self._configStore.exists(targetHost);
        if (!useNtlm) {
            return callback();
        }
        let context = self._connectionContextManager.getConnectionContextFromClientSocket(ctx.clientToProxyRequest.socket);
        if (context && context.isNewOrAuthenticated(targetHost)) {
            const authMode = self.getAuthMode(ctx.serverToProxyResponse, useSso);
            if (authMode === auth_mode_enum_1.AuthModeEnum.NotApplicable) {
                return callback();
            }
            if (authMode === auth_mode_enum_1.AuthModeEnum.NotSupported) {
                self._debug.log("Received 401 with unsupported protocol in www-authenticate header.", ctx.serverToProxyResponse.headers["www-authenticate"], "Ignoring.");
                return callback();
            }
            // Grab PeerCertificate for NTLM channel binding
            if (ctx.isSSL) {
                let tlsSocket = ctx.serverToProxyResponse.connection;
                let peerCert = tlsSocket.getPeerCertificate();
                // getPeerCertificate may return an empty object.
                // Validate that it has fingerprint256 attribute (added in Node 9.8.0)
                if (peerCert.fingerprint256) {
                    context.peerCert = peerCert;
                }
                else {
                    self._debug.log("Could not retrieve PeerCertificate for NTLM channel binding.");
                }
            }
            if (authMode === auth_mode_enum_1.AuthModeEnum.Negotiate) {
                self._debug.log("Received 401 with Negotiate in www-authenticate header. Starting handshake.");
                if (useSso) {
                    context.winSso = new self.WinSsoFacade("Negotiate", ctx.proxyToServerRequestOptions.host, context.peerCert);
                }
                self._negotiateManager.handshake(ctx, targetHost, context, (err, res) => self.handshakeCallback(ctx, err, res));
            }
            if (authMode === auth_mode_enum_1.AuthModeEnum.NTLM) {
                self._debug.log("Received 401 with NTLM in www-authenticate header. Starting handshake.");
                if (useSso) {
                    context.winSso = new self.WinSsoFacade("NTLM", ctx.proxyToServerRequestOptions.host, context.peerCert);
                }
                self._ntlmManager.handshake(ctx, targetHost, context, useSso, (err, res) => self.handshakeCallback(ctx, err, res));
            }
        }
        else {
            return callback();
        }
    }
    handshakeCallback(ctx, err, res) {
        if (err) {
            self._debug.log("Cannot perform handshake.");
        }
        if (res) {
            if (ctx.clientToProxyRequest.headers["proxy-connection"]) {
                res.headers["proxy-connection"] = "keep-alive";
                if (res.statusCode && res.statusCode !== 401) {
                    res.headers["connection"] = "keep-alive";
                }
                else {
                    res.headers["connection"] = "close";
                }
            }
            ctx.proxyToClientResponse.writeHead(res.statusCode || 401, self.filterAndCanonizeHeaders(res.headers));
            res.on("data", chunk => ctx.proxyToClientResponse.write(chunk));
            res.on("end", () => ctx.proxyToClientResponse.end());
            res.resume();
        }
        else {
            // No response available, send empty 401 with headers from initial response
            let headers = ctx.serverToProxyResponse.headers;
            if (headers["proxy-connection"]) {
                headers["proxy-connection"] = "keep-alive";
                headers["connection"] = "close";
            }
            ctx.proxyToClientResponse.writeHead(401, self.filterAndCanonizeHeaders(headers));
            ctx.proxyToClientResponse.end();
        }
    }
    onConnect(req, socket, head, callback) {
        if (!req.url) {
            self._debug.log("Invalid connect request - cannot read target url");
            return callback();
        }
        let targetHost = url_converter_1.toCompleteUrl(req.url, true, true);
        if (self._configStore.existsOrUseSso(targetHost)) {
            return callback();
        }
        if (self._upstreamProxyManager.hasHttpsUpstreamProxy(targetHost)) {
            // Don't tunnel if we need to go through an upstream proxy
            return callback();
        }
        // Let non-NTLM hosts tunnel through
        self._debug.log("Tunnel to", req.url);
        let conn = net_1.default.connect({
            port: +targetHost.port,
            host: targetHost.hostname,
            allowHalfOpen: true
        }, function () {
            conn.on("finish", () => {
                self._connectionContextManager.removeTunnel(socket);
                socket.destroy();
            });
            socket.on("close", () => {
                self._debug.log("client closed socket, closing tunnel to ", req.url);
                conn.end();
            });
            socket.write("HTTP/1.1 200 OK\r\n\r\n", "UTF-8", function () {
                conn.write(head);
                conn.pipe(socket);
                socket.pipe(conn);
                self._connectionContextManager.addTunnel(socket, conn);
            });
        });
        conn.on("error", function (err) {
            filterSocketConnReset(err, "PROXY_TO_SERVER_SOCKET", req.url);
        });
        socket.on("error", function (err) {
            filterSocketConnReset(err, "CLIENT_TO_PROXY_SOCKET", req.url);
        });
        // Since node 0.9.9, ECONNRESET on sockets are no longer hidden
        function filterSocketConnReset(err, socketDescription, url) {
            if (err.code === "ECONNRESET") {
                self._debug.log("Got ECONNRESET on " +
                    socketDescription +
                    ", ignoring. Target: " +
                    url);
            }
            else {
                self._debug.log("Got unexpected error on " + socketDescription + ". Target: " + url, err);
            }
        }
    }
    filterAndCanonizeHeaders(originalHeaders) {
        let headers = {};
        for (let key in originalHeaders) {
            let canonizedKey = key.trim();
            if (/^public\-key\-pins/i.test(canonizedKey)) {
                // HPKP header => filter
                continue;
            }
            if (!nodeCommon._checkInvalidHeaderChar(originalHeaders[key])) {
                headers[canonizedKey] = originalHeaders[key];
            }
        }
        return headers;
    }
};
NtlmProxyMitm = __decorate([
    inversify_1.injectable(),
    __param(0, inversify_1.inject(dependency_injection_types_1.TYPES.IConfigStore)),
    __param(1, inversify_1.inject(dependency_injection_types_1.TYPES.IConfigServer)),
    __param(2, inversify_1.inject(dependency_injection_types_1.TYPES.IConnectionContextManager)),
    __param(3, inversify_1.inject(dependency_injection_types_1.TYPES.NewableIWinSsoFacade)),
    __param(4, inversify_1.inject(dependency_injection_types_1.TYPES.INegotiateManager)),
    __param(5, inversify_1.inject(dependency_injection_types_1.TYPES.INtlmManager)),
    __param(6, inversify_1.inject(dependency_injection_types_1.TYPES.IUpstreamProxyManager)),
    __param(7, inversify_1.inject(dependency_injection_types_1.TYPES.IDebugLogger)),
    __metadata("design:paramtypes", [Object, Object, Object, Object, Object, Object, Object, Object])
], NtlmProxyMitm);
exports.NtlmProxyMitm = NtlmProxyMitm;
