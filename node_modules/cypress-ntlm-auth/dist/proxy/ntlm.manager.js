"use strict";
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var __param = (this && this.__param) || function (paramIndex, decorator) {
    return function (target, key) { decorator(target, key, paramIndex); }
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const inversify_1 = require("inversify");
const http_1 = __importDefault(require("http"));
const https_1 = __importDefault(require("https"));
const ntlm_state_enum_1 = require("../models/ntlm.state.enum");
const dependency_injection_types_1 = require("./dependency.injection.types");
let NtlmManager = class NtlmManager {
    constructor(configStore, ntlm, debug) {
        this._configStore = configStore;
        this._ntlm = ntlm;
        this._debug = debug;
    }
    handshake(ctx, ntlmHostUrl, context, useSso, callback) {
        context.setState(ntlmHostUrl, ntlm_state_enum_1.NtlmStateEnum.NotAuthenticated);
        let config;
        let type1msg;
        let type1header;
        if (useSso) {
            try {
                type1header = context.winSso.createAuthRequestHeader();
            }
            catch (err) {
                return callback(err, ctx.serverToProxyResponse);
            }
        }
        else {
            config = this._configStore.get(ntlmHostUrl);
            type1msg = this._ntlm.createType1Message(config.ntlmVersion, config.workstation, config.domain);
            type1header = type1msg.header();
        }
        this.dropOriginalResponse(ctx);
        let requestOptions = {
            method: ctx.proxyToServerRequestOptions.method,
            path: ctx.proxyToServerRequestOptions.path,
            host: ctx.proxyToServerRequestOptions.host,
            port: ctx.proxyToServerRequestOptions.port,
            agent: ctx.proxyToServerRequestOptions.agent
        };
        requestOptions.headers = {};
        requestOptions.headers["authorization"] = type1header;
        requestOptions.headers["connection"] = "keep-alive";
        let proto = ctx.isSSL ? https_1.default : http_1.default;
        let type1req = proto.request(requestOptions, type1res => {
            type1res.pause();
            if (this.canHandleNtlmAuthentication(type1res) === false) {
                this._debug.log("NTLM authentication failed (www-authenticate with NTLM not found in server response) with host " +
                    ntlmHostUrl.href);
                context.setState(ntlmHostUrl, ntlm_state_enum_1.NtlmStateEnum.NotAuthenticated);
                return callback(new Error("NTLM authentication failed (www-authenticate with NTLM not found in server response) with host " +
                    ntlmHostUrl.href), type1res);
            }
            context.setState(ntlmHostUrl, ntlm_state_enum_1.NtlmStateEnum.Type2Received);
            let type2msg;
            try {
                type2msg = this._ntlm.decodeType2Message(type1res.headers["www-authenticate"]);
                this._debug.log("Received NTLM message type 2, using NTLMv" + type2msg.version);
                this.debugHeader(type1res.headers["www-authenticate"], true);
                this.debugHeader(type2msg, false);
            }
            catch (err) {
                this._debug.log("Cannot parse NTLM message type 2 from host", ntlmHostUrl.href);
                this._debug.log(err);
                context.setState(ntlmHostUrl, ntlm_state_enum_1.NtlmStateEnum.NotAuthenticated);
                return callback(new Error("Cannot parse NTLM message type 2 from host " + ntlmHostUrl.href), type1res);
            }
            let type3msg;
            let type3header;
            if (useSso) {
                try {
                    type3header = context.winSso.createAuthResponseHeader(type1res.headers["www-authenticate"] || "");
                }
                catch (err) {
                    return callback(err, type1res);
                }
            }
            else {
                type3msg = this._ntlm.createType3Message(type1msg, type2msg, config.username, config.password, config.workstation, config.domain, undefined, undefined);
                type3header = type3msg.header();
            }
            let type3requestOptions = {
                method: ctx.proxyToServerRequestOptions.method,
                path: ctx.proxyToServerRequestOptions.path,
                host: ctx.proxyToServerRequestOptions.host,
                port: ctx.proxyToServerRequestOptions.port,
                agent: ctx.proxyToServerRequestOptions.agent,
                headers: ctx.proxyToServerRequestOptions.headers
            };
            if (type3requestOptions.headers) {
                // Always true, silent the compiler
                type3requestOptions.headers["authorization"] = type3header;
            }
            type1res.on("end", () => {
                let type3req = proto.request(type3requestOptions, type3res => {
                    type3res.pause();
                    this.handshakeResponse(type3res, ntlmHostUrl, context, () => {
                        return callback(undefined, type3res);
                    });
                });
                type3req.on("error", err => {
                    this._debug.log("Error while sending NTLM message type 3:", err);
                    context.setState(ntlmHostUrl, ntlm_state_enum_1.NtlmStateEnum.NotAuthenticated);
                    return callback(err);
                });
                this._debug.log("Sending NTLM message type 3 with initial client request");
                this.debugHeader(type3header, true);
                context.setState(ntlmHostUrl, ntlm_state_enum_1.NtlmStateEnum.Type3Sent);
                type3req.write(context.getRequestBody());
                type3req.end();
            });
            type1res.resume(); // complete message to reuse socket
        });
        type1req.on("error", err => {
            this._debug.log("Error while sending NTLM message type 1:", err);
            context.setState(ntlmHostUrl, ntlm_state_enum_1.NtlmStateEnum.NotAuthenticated);
            return callback(err);
        });
        this._debug.log("Sending  NTLM message type 1");
        this.debugHeader(type1header, true);
        context.setState(ntlmHostUrl, ntlm_state_enum_1.NtlmStateEnum.Type1Sent);
        type1req.end();
    }
    handshakeResponse(res, ntlmHostUrl, context, callback) {
        let authState = context.getState(ntlmHostUrl);
        if (authState === ntlm_state_enum_1.NtlmStateEnum.Type3Sent) {
            if (res.statusCode === 401) {
                this._debug.log("NTLM authentication failed (invalid credentials) with host", ntlmHostUrl.href);
                context.setState(ntlmHostUrl, ntlm_state_enum_1.NtlmStateEnum.NotAuthenticated);
                return callback();
            }
            // According to NTLM spec, all other responses than 401 shall be treated as authentication successful
            this._debug.log("NTLM authentication successful with host", ntlmHostUrl.href);
            context.setState(ntlmHostUrl, ntlm_state_enum_1.NtlmStateEnum.Authenticated);
            return callback();
        }
        this._debug.log("Response from server in unexpected NTLM state " +
            authState +
            ", resetting NTLM auth. Host", ntlmHostUrl.href);
        context.setState(ntlmHostUrl, ntlm_state_enum_1.NtlmStateEnum.NotAuthenticated);
        return callback();
    }
    dropOriginalResponse(ctx) {
        ctx.onResponseData((ctx, chunk, callback) => {
            return;
        });
        ctx.onResponseEnd((ctx, callback) => {
            return;
        });
        ctx.serverToProxyResponse.resume();
    }
    acceptsNtlmAuthentication(res) {
        // Ensure that we're talking NTLM here
        const wwwAuthenticate = res.headers["www-authenticate"];
        if (wwwAuthenticate &&
            wwwAuthenticate
                .toUpperCase()
                .split(", ")
                .indexOf("NTLM") !== -1) {
            return true;
        }
        return false;
    }
    canHandleNtlmAuthentication(res) {
        if (res && res.statusCode === 401) {
            // Ensure that we're talking NTLM here
            const wwwAuthenticate = res.headers["www-authenticate"];
            if (wwwAuthenticate && wwwAuthenticate.startsWith("NTLM ")) {
                return true;
            }
        }
        return false;
    }
    debugHeader(obj, brackets) {
        if (process.env.DEBUG_NTLM_HEADERS &&
            process.env.DEBUG_NTLM_HEADERS === "1") {
            if (brackets) {
                this._debug.log("[" + obj + "]");
            }
            else {
                this._debug.log(obj);
            }
        }
    }
};
NtlmManager = __decorate([
    inversify_1.injectable(),
    __param(0, inversify_1.inject(dependency_injection_types_1.TYPES.IConfigStore)),
    __param(1, inversify_1.inject(dependency_injection_types_1.TYPES.INtlm)),
    __param(2, inversify_1.inject(dependency_injection_types_1.TYPES.IDebugLogger)),
    __metadata("design:paramtypes", [Object, Object, Object])
], NtlmManager);
exports.NtlmManager = NtlmManager;
