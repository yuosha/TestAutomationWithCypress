"use strict";
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var __param = (this && this.__param) || function (paramIndex, decorator) {
    return function (target, key) { decorator(target, key, paramIndex); }
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const dependency_injection_types_1 = require("../proxy/dependency.injection.types");
const inversify_1 = require("inversify");
const axios_1 = __importDefault(require("axios"));
let self;
let CypressNtlm = class CypressNtlm {
    constructor(portsFileService, debug) {
        this._portsFileService = portsFileService;
        this._debug = debug;
        // Keep track of instance handle since we need it when responding to timer events
        self = this;
    }
    checkCypressIsInstalled() {
        try {
            const result = require.resolve("cypress");
            return result !== null && result !== undefined;
        }
        catch (_a) {
            return false;
        }
    }
    checkProxyIsRunning(timeout, interval) {
        return new Promise((resolve, reject) => {
            const timeoutTimerId = global.setTimeout(handleTimeout, timeout);
            let intervalTimerId;
            function handleTimeout() {
                clearTimeout(intervalTimerId);
                const error = new Error("ntlm-proxy not found before time out");
                error.name = "PATH_CHECK_TIMED_OUT";
                reject(error);
            }
            function handleInterval() {
                if (self._portsFileService.exists()) {
                    try {
                        const portsFile = self._portsFileService.parse();
                        axios_1.default
                            .get(portsFile.configApiUrl + "/alive", { timeout: 1000 })
                            .then(res => {
                            if (res.status === 200) {
                                clearTimeout(timeoutTimerId);
                                self._debug.log("Found running ntlm-proxy!");
                                resolve(portsFile);
                            }
                            else {
                                self._debug.log("Invalid response from ntlm-proxy. May just have been removed. Retrying...");
                                intervalTimerId = global.setTimeout(handleInterval, interval);
                            }
                        })
                            .catch(() => {
                            self._debug.log("Failed to contact ntlm-proxy. May just have been removed. Retrying...");
                            intervalTimerId = global.setTimeout(handleInterval, interval);
                        });
                    }
                    catch (err) {
                        // Intentionally ignore
                        self._debug.log("Failed to parse ports file. May just have been removed. Retrying...");
                        intervalTimerId = global.setTimeout(handleInterval, interval);
                    }
                }
                else {
                    intervalTimerId = global.setTimeout(handleInterval, interval);
                }
            }
            if (self._portsFileService.recentlyModified()) {
                // Ports file is fresh => ntlm-proxy recently started
                handleInterval();
            }
            else {
                // Older ports file => old ntlm-proxy instance still running or failed to cleanup
                // Wait 2000 ms to avoid finding an old proxy instance
                self._debug.log("Older ports file present. Waiting 2000 ms for new proxy instance to remove it.");
                intervalTimerId = global.setTimeout(handleInterval, 2000);
            }
        });
    }
};
CypressNtlm = __decorate([
    inversify_1.injectable(),
    __param(0, inversify_1.inject(dependency_injection_types_1.TYPES.IPortsFileService)),
    __param(1, inversify_1.inject(dependency_injection_types_1.TYPES.IDebugLogger)),
    __metadata("design:paramtypes", [Object, Object])
], CypressNtlm);
exports.CypressNtlm = CypressNtlm;
